package amplify;

import org.jivesoftware.smack.*;
import org.jivesoftware.smack.filter.PacketTypeFilter;
import org.jivesoftware.smack.packet.DefaultPacketExtension;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smack.packet.Packet;
import org.jivesoftware.smack.packet.PacketExtension;
import org.jivesoftware.smack.provider.PacketExtensionProvider;
import org.jivesoftware.smack.provider.ProviderManager;
import org.jivesoftware.smack.tcp.XMPPTCPConnection;
import org.jivesoftware.smack.util.StringUtils;
import org.vertx.java.core.Vertx;
import org.vertx.java.core.eventbus.EventBus;
import org.vertx.java.core.eventbus.impl.DefaultEventBus;
import org.vertx.java.core.json.JsonObject;
import org.vertx.java.core.logging.Logger;
import org.vertx.java.core.logging.impl.LoggerFactory;
import org.vertx.java.platform.Verticle;
import org.xmlpull.v1.XmlPullParser;

import javax.net.ssl.SSLSocketFactory;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class XmppGcmClient {
    private static final Logger logger = LoggerFactory.getLogger(LoggingConnectionListener.class);
    private static final String GCM_SERVER = "gcm.googleapis.com";
    private static final int GCM_PORT = 5235;

    private static final String GCM_ELEMENT_NAME = "gcm";
    private static final String GCM_NAMESPACE = "google:mobile:data";
    private final EventBus eventBus;

    private XMPPConnection xmppConnection;

    public XmppGcmClient(EventBus eventBus) {
        this.eventBus = eventBus;
    }

    /**
     * Indicates whether the connection is in draining state, which means that it
     * will not accept any new downstream messages.
     */
    protected volatile boolean connectionDraining = false;

    static {
        ProviderManager.addExtensionProvider(GCM_ELEMENT_NAME, GCM_NAMESPACE,
                new PacketExtensionProvider() {
                    @Override
                    public PacketExtension parseExtension(XmlPullParser parser) throws Exception {
                        String json = parser.nextText();
                        return new GcmPacketExtension(json);
                    }
                });
    }

    /**
     * XMPP Packet Extension for GCM Cloud Connection Server.
     */
    private static final class GcmPacketExtension extends DefaultPacketExtension {

        private final String json;

        public GcmPacketExtension(String json) {
            super(GCM_ELEMENT_NAME, GCM_NAMESPACE);
            this.json = json;
        }

        public String getJson() {
            return json;
        }

        @Override
        public String toXML() {
            return String.format("<%s xmlns=\"%s\">%s</%s>",
                    GCM_ELEMENT_NAME, GCM_NAMESPACE,
                    StringUtils.escapeForXML(json), GCM_ELEMENT_NAME);
        }

        public Packet toPacket() {
            Message message = new Message();
            message.addExtension(this);
            return message;
        }
    }

    private final class LoggingConnectionListener implements ConnectionListener {
        @Override
        public void connected(XMPPConnection xmppConnection) {
            logger.info("Connected.");
        }

        @Override
        public void authenticated(XMPPConnection xmppConnection) {
            logger.info("Authenticated.");
        }

        @Override
        public void reconnectionSuccessful() {
            logger.info("Reconnecting..");
        }

        @Override
        public void reconnectionFailed(Exception e) {
            logger.info("Reconnection failed.. ", e);
        }

        @Override
        public void reconnectingIn(int seconds) {
            logger.info("Reconnecting in " + seconds + " secs");
        }

        @Override
        public void connectionClosedOnError(Exception e) {
            logger.info("Connection closed on error.", e);
        }

        @Override
        public void connectionClosed() {
            logger.info("Connection closed.");
        }
    }

    /**
     * Returns a random message id to uniquely identify a message.
     *
     * <p>Note: This is generated by a pseudo random number generator for
     * illustration purpose, and is not guaranteed to be unique.
     */
    public static String nextMessageId() {
        return "m-" + UUID.randomUUID().toString();
    }

    /**
     * Sends a downstream message to GCM.
     *
     * @return true if the message has been successfully sent.
     */
    public boolean sendDownstreamMessage(String jsonRequest) throws SmackException.NotConnectedException {
        if (!connectionDraining) {
            send(jsonRequest);
        }
        else {
            logger.info("Dropping downstream message since the connection is draining");
        }

        return !connectionDraining;
    }

    public static String transformSendMessage(JsonObject sendMessage, String messageId) {
        JsonObject message = new JsonObject();
        JsonObject payload = sendMessage.getObject("payload");
        String collapseKey = message.getString("collapseKey");
        Long timeToLive = message.getLong("timeToLive");
        Boolean delayWhileIdle = message.getBoolean("delayWhileIdle");

        message.putString("to", sendMessage.getString("toRegId"));
        if (collapseKey != null) {
            message.putString("collapse_key", collapseKey);
        }
        if (timeToLive != null) {
            message.putNumber("time_to_live", timeToLive);
        }
        if (delayWhileIdle != null && delayWhileIdle) {
            message.putBoolean("delay_while_idle", true);
        }

        payload.putString("EmbeddedMessageId", messageId);
        message.putString("message_id", messageId);
        message.putObject("data", payload);

        return message.encode();
    }

    /**
     * Connects to GCM Cloud Connection Server using the supplied credentials.
     *
     * @param senderId Your GCM project number
     * @param apiKey API Key of your project
     */
    public void connect(long senderId, String apiKey) throws XMPPException, IOException, SmackException {
        xmppConnection = contectToGCM();

        xmppConnection.addConnectionListener(new LoggingConnectionListener());

        // Handle incoming packets
        xmppConnection.addPacketListener(new PacketListener() {

            @Override
            public void processPacket(Packet packet) {

                //container.logger().info("Received: " + packet.toXML());
                eventBus.send("send-metric", MetricsVerticle.getErrorMetricJson("Received: " + packet.toXML(), GASeverity.INFO));
                Message incomingMessage = (Message) packet;
                GcmPacketExtension gcmPacket =
                        (GcmPacketExtension) incomingMessage.
                                getExtension(GCM_NAMESPACE);
                String json = gcmPacket.getJson();
                try {
                    JsonObject jsonObject = new JsonObject(json);

                    // present for "ack"/"nack", null otherwise
                    String messageType = jsonObject.getString("message_type");

                    if (messageType == null) {
                        // Normal upstream data message
                        handleUpstreamMessage(jsonObject);

                        // Send ACK to CCS
                        String messageId = jsonObject.getString("message_id");
                        String from = jsonObject.getString("from");
                        String ack = createJsonAck(from, messageId);
                        send(ack);
                    } else if ("ack".equals(messageType)) {
                        // Process Ack
                        handleAckReceipt(jsonObject);
                    } else if ("nack".equals(messageType)) {
                        // Process Nack
                        handleNackReceipt(jsonObject);
                    } else if ("control".equals(messageType)) {
                        // Process control message
                        handleControlMessage(jsonObject);
                    } else {
                        logger.warn("Unrecognized message type " + messageType);
                    }
                }  catch (Exception e) {
                    logger.fatal("Failed to process packet", e);
                }
            }
        }, new PacketTypeFilter(Message.class));

        // Log all outgoing packets
        xmppConnection.addPacketInterceptor(new PacketInterceptor() {
            @Override
            public void interceptPacket(Packet packet) {
                logger.info("Sent: " + packet.toXML());
            }
        }, new PacketTypeFilter(Message.class));

        xmppConnection.login(senderId + "@gcm.googleapis.com", apiKey);
    }

    private XMPPTCPConnection contectToGCM() throws IOException, XMPPException, SmackException {

        ConnectionConfiguration config = new ConnectionConfiguration(GCM_SERVER, GCM_PORT);
        config.setSecurityMode(ConnectionConfiguration.SecurityMode.enabled);
        config.setReconnectionAllowed(true);
        config.setRosterLoadedAtLogin(false);
        config.setSendPresence(false);
        config.setSocketFactory(SSLSocketFactory.getDefault());

        XMPPTCPConnection connection = new XMPPTCPConnection(config);
        connection.connect();

        return connection;
    }

    /**
     * Creates a JSON encoded ACK message for an upstream message received
     * from an application.
     *
     * @param to RegistrationId of the device who sent the upstream message.
     * @param messageId messageId of the upstream message to be acknowledged to CCS.
     * @return JSON encoded ack.
     */
    protected static String createJsonAck(String to, String messageId) {
        Map<String, Object> message = new HashMap<>();
        message.put("message_type", "ack");
        message.put("to", to);
        message.put("message_id", messageId);

        return new JsonObject(message).encode();
    }

    /**
     * Handles an ACK.
     *
     * <p>Logs a INFO message, but subclasses could override it to
     * properly handle ACKs.
     */
    private void handleAckReceipt(JsonObject jsonObject) {
        String messageId = jsonObject.getString("message_id");
        String from = jsonObject.getString("from");
        logger.info("handleAckReceipt() from: " + from + ", messageId: " + messageId);
    }

    /**
     * Handles a NACK.
     *
     * <p>Logs a INFO message, but subclasses could override it to
     * properly handle NACKs.
     */
    private void handleNackReceipt(JsonObject jsonObject) {
        String messageId = jsonObject.getString("message_id");
        String from = jsonObject.getString("from");
        logger.info("handleNackReceipt() from: " + from + ", messageId: " + messageId);
    }

    private void handleControlMessage(JsonObject jsonObject) {
        logger.info("handleControlMessage(): " + jsonObject);
        String controlType = jsonObject.getString("control_type");
        if ("CONNECTION_DRAINING".equals(controlType)) {
            connectionDraining = true;
        } else {
            logger.info("Unrecognized control type: " + controlType + ". This could happen if new features are " + "added to the CCS protocol.");
        }
    }


    /**
     * Handles an upstream data message from a device application.
     *
     * <p>This sample echo server sends an echo message back to the device.
     * Subclasses should override this method to properly process upstream messages.
     */
    private void handleUpstreamMessage(JsonObject jsonObject) {
        // PackageName of the application that sent this message.
        String category = jsonObject.getString("category");
        String from = jsonObject.getString("from");
        @SuppressWarnings("unchecked")
        JsonObject payload = jsonObject.getObject("data");
        payload.putString("ECHO", "Application: " + category);

        // Send an ECHO response back
        String echo = createJsonMessage(from, nextMessageId(), payload, "echo:CollapseKey", null, false);

        try {
            sendDownstreamMessage(echo);
        } catch (SmackException.NotConnectedException e) {
            logger.warn("Not connected anymore, echo message is not sent", e);

        }
    }

    /**
     * Creates a JSON encoded GCM message.
     *
     * @param to RegistrationId of the target device (Required).
     * @param messageId Unique messageId for which CCS will send an
     *         "ack/nack" (Required).
     * @param payload Message content intended for the application. (Optional).
     * @param collapseKey GCM collapse_key parameter (Optional).
     * @param timeToLive GCM time_to_live parameter (Optional).
     * @param delayWhileIdle GCM delay_while_idle parameter (Optional).
     * @return JSON encoded GCM message.
     */
    private static String createJsonMessage(String to, String messageId,
                                           JsonObject payload, String collapseKey, Long timeToLive,
                                           Boolean delayWhileIdle) {
        JsonObject message = new JsonObject();
        message.putString("to", to);
        if (collapseKey != null) {
            message.putString("collapse_key", collapseKey);
        }
        if (timeToLive != null) {
            message.putNumber("time_to_live", timeToLive);
        }
        if (delayWhileIdle != null && delayWhileIdle) {
            message.putBoolean("delay_while_idle", true);
        }
        message.putString("message_id", messageId);
        message.putObject("data", payload);

        return message.encode();
    }

    /**
     * Sends a packet with contents provided.
     */
    private void send(String jsonRequest) throws SmackException.NotConnectedException {
        Packet request = new GcmPacketExtension(jsonRequest).toPacket();
        xmppConnection.sendPacket(request);
    }
}
